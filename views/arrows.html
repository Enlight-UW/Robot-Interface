<!DOCTYPE html>
<html>
<head>
<meta name="Tennis Match" content="Tennis match played first to 11 points">
  <meta charset="utf-8">
  <title>TWGL 101</title>
  <!-- you need to load TWGL from somewhere -
    -- this grabs it from the CS server, which
    -- might take a while
    -->
  <canvas id="myCanvas" 
	   width="800" height="600"
	   style="border:1px solid #000;">
  </canvas>
    <br/>
  <input id="slider1" type="range" min="-100" max="100" />
  <input id="slider2" type="range" min="-100" max="100" />
  <button onclick="updateSpin(Math.PI * 2, 0, 0, 0)">Up</button>
  <button onclick="updateSpin(0, Math.PI * 2, 0, 0)">Down</button>
  <button onclick="updateSpin(0, 0, Math.PI * 2, 0)">Left</button>
  <button onclick="updateSpin(0, 0, 0, Math.PI * 2)">Right</button>
    <script src="twgl-full.min.js"></script>
    <script>
	
//global variables to determine if arrow should be spinning
var upSpin = 0;
var downSpin = 0;
var leftSpin = 0;
var rightSpin = 0;

function updateSpin(up, down, left, right) {
	upSpin += up;
	downSpin += down;
	leftSpin += left;
	rightSpin += right;
}

function setup() { 
  var canvas = document.getElementById('myCanvas');
  var context = canvas.getContext('2d');
  var m4 = twgl.m4;
  
  var slider1 = document.getElementById('slider1');
  var slider2 = document.getElementById('slider2');
  slider1.value = 35;
  slider2.value = 0;
                
  function moveToTx(x,y,z,Tx) {
    var loc = [x,y,z];
    var locTx = m4.transformPoint(Tx,loc);
    context.moveTo(locTx[0]+250,-locTx[1]+250);
  }

  function lineToTx(x,y,z,Tx) {
    var loc = [x,y,z];
    var locTx = m4.transformPoint(Tx,loc);
    context.lineTo(locTx[0]+250,-locTx[1]+250);
  }
                
  function drawAxes(Tx) {
    // A little cross on the front face, for identification
    moveToTx(0,0,0,Tx);lineToTx(50,0,0,Tx);context.stroke();
    moveToTx(0,0,0,Tx);lineToTx(0,150,0,Tx);context.stroke();
    moveToTx(0,0,0,Tx);lineToTx(0,0,250,Tx);context.stroke();
  }

  function drawCube(cube, Tx) {
	
	//centers of cube
	var xc=cube.xc, yc=cube.yc, zc=cube.zc;
	
	//radiuses of cube
    var rx=cube.xr,ry=cube.yr,zr=cube.zr;
	
	context.beginPath();
	
	//color of cube
	context.fillStyle = cube.color;
	
  
    // Twelve edges of a cube
    moveToTx(xc - rx,yc - ry,zc - zr,Tx);lineToTx(xc + rx,yc - ry,zc - zr,Tx);
    lineToTx(xc + rx,yc + ry,zc - zr,Tx);lineToTx(xc - rx,yc + ry,zc - zr,Tx);context.stroke();context.fill();
    moveToTx(xc + rx,yc - ry,zc - zr,Tx);lineToTx(xc + rx,yc - ry,zc + zr,Tx);
    lineToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc - zr,Tx);context.stroke();context.fill();
    moveToTx(xc + rx,yc - ry,zc + zr,Tx);lineToTx(xc - rx,yc - ry,zc + zr,Tx);
    lineToTx(xc - rx,yc + ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
    moveToTx(xc - rx,yc - ry,zc + zr,Tx);lineToTx(xc - rx,yc - ry,zc - zr,Tx);
    lineToTx(xc - rx,yc + ry,zc - zr,Tx);lineToTx(xc - rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	
	//fill top part of cube
	moveToTx(xc - rx,yc + ry,zc - zr,Tx);lineToTx(xc - rx,yc + ry,zc + zr,Tx);
	lineToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc - zr,Tx);context.fill();
	
	context.closePath();
  }
  
  function drawArrow(arrow, Tx) {
  
	context.save();
	//centers of arrow
	var xc=arrow.xc, yc=arrow.yc, zc=arrow.zc;
	
	//radiuses of arrow
    var rx=arrow.xr,ry=arrow.yr,zr=arrow.zr;
	
	//color of head
	context.fillStyle = arrow.fColor;
	context.strokeStyle = arrow.sColor;
	context.lineWidth = 5;
  
    // rectangle
	context.beginPath();
    moveToTx(xc - rx,yc - ry,zc - zr,Tx);lineToTx(xc + rx,yc - ry,zc - zr,Tx);
    lineToTx(xc + rx,yc - ry,zc + zr,Tx);lineToTx(xc - rx,yc - ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	context.beginPath();
    moveToTx(xc - rx,yc + ry,zc - zr,Tx);lineToTx(xc + rx,yc + ry,zc - zr,Tx);
    lineToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc - rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	context.beginPath();
    moveToTx(xc - rx,yc - ry,zc - zr,Tx);lineToTx(xc - rx,yc - ry,zc + zr,Tx);
    lineToTx(xc - rx,yc + ry,zc + zr,Tx);lineToTx(xc - rx,yc + ry,zc - zr,Tx);context.stroke();context.fill();
	context.closePath();
	context.beginPath();
    moveToTx(xc + rx,yc - ry,zc - zr,Tx);lineToTx(xc + rx,yc - ry,zc + zr,Tx);
    lineToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc - zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	// triangle
	
	//top half
	context.beginPath();
	moveToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc + 2*rx,yc + ry,zc + zr,Tx);
	lineToTx(xc,yc + ry,zc + 2*zr,Tx);lineToTx(xc - 2*rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//bottom half
	context.beginPath();
	moveToTx(xc + rx,yc - ry,zc + zr,Tx);lineToTx(xc + 2*rx,yc - ry,zc + zr,Tx);
	lineToTx(xc,yc - ry,zc + 2*zr,Tx);lineToTx(xc - 2*rx,yc - ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//left side forward
	context.beginPath();
	moveToTx(xc + 2*rx,yc + ry,zc + zr,Tx);lineToTx(xc,yc + ry,zc + 2*zr,Tx);
	lineToTx(xc,yc - ry,zc + 2*zr,Tx);lineToTx(xc + 2*rx,yc - ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//left side backward
	context.beginPath();
	moveToTx(xc + 2*rx,yc + ry,zc + zr,Tx);lineToTx(xc + 2*rx,yc - ry,zc + zr,Tx);
	lineToTx(xc + rx,yc - ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//right side forward
	context.beginPath();
	moveToTx(xc - 2*rx,yc + ry,zc + zr,Tx);lineToTx(xc,yc + ry,zc + 2*zr,Tx);
	lineToTx(xc,yc - ry,zc + 2*zr,Tx);lineToTx(xc - 2*rx,yc - ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//right side backward
	context.beginPath();
	moveToTx(xc - 2*rx,yc + ry,zc + zr,Tx);lineToTx(xc - 2*rx,yc - ry,zc + zr,Tx);
	lineToTx(xc - rx,yc - ry,zc + zr,Tx);lineToTx(xc - rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	context.restore();
  }

  function draw() {
    // hack to clear the canvas fast
    canvas.width = canvas.width;
    
    var angle1 = slider1.value*0.01*Math.PI;
    var angle2 = 0;
	var angle3 = (slider2.value * 3) + 300;
    var axis = [1,1,1];
  
    var Tmodel=m4.axisRotation(axis,angle2);

    var eye=[500*Math.cos(angle1),angle3,500*Math.sin(angle1)];
    var target=[0,0,0];
    var up=[0,1,0];
    var Tcamera=m4.inverse(m4.lookAt(eye,target,up));   
    
    var Tmodelview=m4.multiply(Tmodel,Tcamera);
	
	var upModel = Tmodel;
	var leftModel = m4.axisRotation([0, 1, 0], Math.PI * 0.5);
	var rightModel = m4.axisRotation([0, 1, 0], Math.PI * -0.5);
	var downModel = m4.axisRotation([0, 1, 0], Math.PI);
	upModel = m4.translate(upModel, [-40, 0, 0]);
	leftModel = m4.translate(leftModel, [160, 0, 80]);
	rightModel = m4.translate(rightModel, [-160, 0, 160]);
	downModel = m4.translate(downModel, [40, 0, 320]);
	
	var upModView = Tmodelview;
	var leftModView = m4.multiply(leftModel, Tcamera);
	var rightModView = m4.multiply(rightModel, Tcamera);
	var downModView = m4.multiply(downModel, Tcamera);
	
	var upAxis = [1, 0, 0];
	var downAxis = [1, 0, 0];
	var leftAxis = [1, 0, 0];
	var rightAxis = [1, 0, 0];
	
	//arrow objects
	var upArrow = {xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr:75, sColor: "white", fColor: "rgb(189,32,49)"};
	var downArrow = {xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr:75, sColor: "white", fColor: "rgb(189,32,49)"};
	var leftArrow = {xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr: 75, sColor: "white", fColor: "rgb(189,32,49)"};
	var rightArrow = {xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr: 75, sColor: "white", fColor: "rgb(189,32,49)"};
	
	//speed the arrows spin
	var spinSpeed = Math.PI / 45;
	
	//backdrop
	var background = {xc: 0, yc: -1, zc: 0, xr: 1600, yr: 1, zr:1600, color: "black"};
	
	//game variable, whether game is running or over
	var game = "running";
	
	//main loop
	function update() {
	
		//clear canvas
		canvas.width = canvas.width;
		
		updateCamera();
		
		
		//resetGame();
		spinArrows();
		
		drawCube(background, Tmodelview);
		drawArrow(upArrow, upModView);
		drawArrow(leftArrow, leftModView);
		drawArrow(downArrow, downModView);
		drawArrow(rightArrow, rightModView);
		
		window.requestAnimationFrame(update);
	}
	
	//bring ui to original setup
	function resetGame() {
		
	}
	
	//spin the arrows when clicked
	function spinArrows() {
		
		//spin up arrow
		if(upSpin > 0) {
			upModel = m4.axisRotate(upModel, upAxis, spinSpeed);
			upModView = m4.multiply(upModel, Tcamera);
		}
		
		//spin down arrow
		if(downSpin > 0) {
			downModel = m4.axisRotate(downModel, downAxis, spinSpeed);
			downModView = m4.multiply(downModel, Tcamera);
		}
		
		//spin left arrow
		if(leftSpin > 0) {
			leftModel = m4.axisRotate(leftModel, leftAxis, spinSpeed);
			leftModView = m4.multiply(leftModel, Tcamera);
		}
		
		//spin right arrow
		if(rightSpin > 0) {
			rightModel = m4.axisRotate(rightModel, rightAxis, spinSpeed);
			rightModView = m4.multiply(rightModel, Tcamera);
		}
		
		//calulate amonut of spin remaining
		upSpin -= spinSpeed;
		downSpin -= spinSpeed;
		leftSpin -= spinSpeed;
		rightSpin -= spinSpeed;
		
		//cannot have negative spin remaining
		if(upSpin < 0) {
			upSpin = 0;
		}
		if(downSpin < 0) {
			downSpin = 0;
		}
		if(leftSpin < 0) {
			leftSpin = 0;
		}
		if(rightSpin < 0) {
			rightSpin = 0;
		}
	}
	
	//update the camera with new slider value
	function updateCamera() {
		
		//update main modelview
		angle1 = slider1.value*0.01*Math.PI;
		angle3 = (slider2.value * 3) + 300;
		
		eye=[Math.cos(-1.57) * 500,angle3,500*Math.sin(-1.57)];
		
        Tcamera=m4.inverse(m4.lookAt(eye,target,up));   
		Tmodelview=m4.multiply(Tmodel,Tcamera);
		upModView = m4.multiply(upModel, Tcamera);
	    leftModView = m4.multiply(leftModel, Tcamera);
	    rightModView = m4.multiply(rightModel, Tcamera);
	    downModView = m4.multiply(downModel, Tcamera);
		console.log("angle1: " + angle1);
		console.log(angle3);

	}
	
    drawAxes(Tcamera);
	update();	
	
  }
  draw();

}
window.onload = setup();

  </script>
</head>
<body>

</body>
</html>