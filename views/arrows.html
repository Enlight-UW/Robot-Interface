<!DOCTYPE html>
<html>
<head>
<meta name="Tennis Match" content="Tennis match played first to 11 points">
  <meta charset="utf-8">
  <title>TWGL 101</title>
  <!-- you need to load TWGL from somewhere -
    -- this grabs it from the CS server, which
    -- might take a while
    -->
  <canvas id="myCanvas" 
	   width="800" height="600"
	   style="border:1px solid #000;">
  </canvas>
    <br/>
  <input id="slider1" type="range" min="-10000" max="0" />
  <input id="slider2" type="range" min="-100" max="100" />
  <button onclick="updateSpin(Math.PI * 2, 0, 0, 0)">Up</button>
  <button onclick="updateSpin(0, Math.PI * 2, 0, 0)">Down</button>
  <button onclick="updateSpin(0, 0, Math.PI * 2, 0)">Left</button>
  <button onclick="updateSpin(0, 0, 0, Math.PI * 2)">Right</button>
  <button onclick="undoQueueMove()">Undo</button>
  <button onclick="startQueueMove()">Submit</button>
    <script src="twgl-full.min.js"></script>
    <script>
	
//global variables to determine if arrow should be spinning
var upSpin = 0;
var downSpin = 0;
var leftSpin = 0;
var rightSpin = 0;

//multipliers for speed
var upSpeed = 0;
var downSpeed = 0;
var leftSpeed = 0;
var rightSpeed = 0;

//queue of directions sent, function replaces them with objects when used
var newArrows = [];

//speed of queue after submission
var queueSpeed = 0;

//number of moves to undo
var undoMoves = 0;

//call this function from outside to spin the arrows, values are how far you want them to rotate
function updateSpin(up, down, left, right) {

	//add value to speed
	upSpin += up;
	downSpin += down;
	leftSpin += left;
	rightSpin += right;
	
	//increase multipliers for each call
	if(up > 0) {
		upSpeed++;
		newArrows.push("up");
	}
	if(down > 0) {
		downSpeed++;
		newArrows.push("down");
	}
	if(left > 0) {
		leftSpeed++;
		newArrows.push("left");
	}
	if(right > 0) {
		rightSpeed++;
		newArrows.push("right");
	}
}

//change the speed so the arrow queue moves, call from outside after submitting moves
function startQueueMove() {
	queueSpeed = 2;
}

//each button click undoes a move
function undoQueueMove() {
	undoMoves++;
}

function setup() { 
  var canvas = document.getElementById('myCanvas');
  var context = canvas.getContext('2d');
  var m4 = twgl.m4;
  
  var slider1 = document.getElementById('slider1');
  var slider2 = document.getElementById('slider2');
  slider1.value = 35;
  slider2.value = 0;
                
  function moveToTx(x,y,z,Tx) {
    var loc = [x,y,z];
    var locTx = m4.transformPoint(Tx,loc);
    context.moveTo(locTx[0]+250,-locTx[1]+250);
  }

  function lineToTx(x,y,z,Tx) {
    var loc = [x,y,z];
    var locTx = m4.transformPoint(Tx,loc);
    context.lineTo(locTx[0]+250,-locTx[1]+250);
  }
                
  function drawAxes(Tx) {
    // A little cross on the front face, for identification
    moveToTx(0,0,0,Tx);lineToTx(50,0,0,Tx);context.stroke();
    moveToTx(0,0,0,Tx);lineToTx(0,150,0,Tx);context.stroke();
    moveToTx(0,0,0,Tx);lineToTx(0,0,250,Tx);context.stroke();
  }

  function drawCube(cube, Tx) {
	
	//centers of cube
	var xc=cube.xc, yc=cube.yc, zc=cube.zc;
	
	//radiuses of cube
    var rx=cube.xr,ry=cube.yr,zr=cube.zr;
	
	context.beginPath();
	
	//color of cube
	context.fillStyle = cube.color;
	
  
    // Twelve edges of a cube
    moveToTx(xc - rx,yc - ry,zc - zr,Tx);lineToTx(xc + rx,yc - ry,zc - zr,Tx);
    lineToTx(xc + rx,yc + ry,zc - zr,Tx);lineToTx(xc - rx,yc + ry,zc - zr,Tx);context.stroke();context.fill();
    moveToTx(xc + rx,yc - ry,zc - zr,Tx);lineToTx(xc + rx,yc - ry,zc + zr,Tx);
    lineToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc - zr,Tx);context.stroke();context.fill();
    moveToTx(xc + rx,yc - ry,zc + zr,Tx);lineToTx(xc - rx,yc - ry,zc + zr,Tx);
    lineToTx(xc - rx,yc + ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
    moveToTx(xc - rx,yc - ry,zc + zr,Tx);lineToTx(xc - rx,yc - ry,zc - zr,Tx);
    lineToTx(xc - rx,yc + ry,zc - zr,Tx);lineToTx(xc - rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	
	//fill top part of cube
	moveToTx(xc - rx,yc + ry,zc - zr,Tx);lineToTx(xc - rx,yc + ry,zc + zr,Tx);
	lineToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc - zr,Tx);context.fill();
	
	context.closePath();
  }
  
  function drawArrow(arrow, Tx) {
  
	context.save();
	//centers of arrow
	var xc=arrow.xc, yc=arrow.yc, zc=arrow.zc;
	
	//radiuses of arrow
    var rx=arrow.xr,ry=arrow.yr,zr=arrow.zr;
	
	//color of head
	context.fillStyle = arrow.fColor;
	context.strokeStyle = arrow.sColor;
	context.lineWidth = 5;
  
    // rectangle
	context.beginPath();
    moveToTx(xc - rx,yc - ry,zc - zr,Tx);lineToTx(xc + rx,yc - ry,zc - zr,Tx);
    lineToTx(xc + rx,yc - ry,zc + zr,Tx);lineToTx(xc - rx,yc - ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	context.beginPath();
    moveToTx(xc - rx,yc + ry,zc - zr,Tx);lineToTx(xc + rx,yc + ry,zc - zr,Tx);
    lineToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc - rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	context.beginPath();
    moveToTx(xc - rx,yc - ry,zc - zr,Tx);lineToTx(xc - rx,yc - ry,zc + zr,Tx);
    lineToTx(xc - rx,yc + ry,zc + zr,Tx);lineToTx(xc - rx,yc + ry,zc - zr,Tx);context.stroke();context.fill();
	context.closePath();
	context.beginPath();
    moveToTx(xc + rx,yc - ry,zc - zr,Tx);lineToTx(xc + rx,yc - ry,zc + zr,Tx);
    lineToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc - zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	// triangle
	
	//top half
	context.beginPath();
	moveToTx(xc + rx,yc + ry,zc + zr,Tx);lineToTx(xc + 2*rx,yc + ry,zc + zr,Tx);
	lineToTx(xc,yc + ry,zc + 2*zr,Tx);lineToTx(xc - 2*rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//bottom half
	context.beginPath();
	moveToTx(xc + rx,yc - ry,zc + zr,Tx);lineToTx(xc + 2*rx,yc - ry,zc + zr,Tx);
	lineToTx(xc,yc - ry,zc + 2*zr,Tx);lineToTx(xc - 2*rx,yc - ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//left side forward
	context.beginPath();
	moveToTx(xc + 2*rx,yc + ry,zc + zr,Tx);lineToTx(xc,yc + ry,zc + 2*zr,Tx);
	lineToTx(xc,yc - ry,zc + 2*zr,Tx);lineToTx(xc + 2*rx,yc - ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//left side backward
	context.beginPath();
	moveToTx(xc + 2*rx,yc + ry,zc + zr,Tx);lineToTx(xc + 2*rx,yc - ry,zc + zr,Tx);
	lineToTx(xc + rx,yc - ry,zc + zr,Tx);lineToTx(xc + rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//right side forward
	context.beginPath();
	moveToTx(xc - 2*rx,yc + ry,zc + zr,Tx);lineToTx(xc,yc + ry,zc + 2*zr,Tx);
	lineToTx(xc,yc - ry,zc + 2*zr,Tx);lineToTx(xc - 2*rx,yc - ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	//right side backward
	context.beginPath();
	moveToTx(xc - 2*rx,yc + ry,zc + zr,Tx);lineToTx(xc - 2*rx,yc - ry,zc + zr,Tx);
	lineToTx(xc - rx,yc - ry,zc + zr,Tx);lineToTx(xc - rx,yc + ry,zc + zr,Tx);context.stroke();context.fill();
	context.closePath();
	
	context.restore();
  }

  function draw() {
    // hack to clear the canvas fast
    canvas.width = canvas.width;
    
    var angle1 = slider1.value*0.01*Math.PI;
    var angle2 = 0;
	var angle3 = (slider2.value * 3) + 300;
    var axis = [1,1,1];
  
    var Tmodel=m4.axisRotation(axis,angle2);

    var eye=[500*Math.cos(angle1),angle3,500*Math.sin(angle1)];
    var target=[0,0,0];
    var up=[0,1,0];
    var Tcamera=m4.inverse(m4.lookAt(eye,target,up));   
    
    var Tmodelview=m4.multiply(Tmodel,Tcamera);
	
	var upModel = Tmodel;
	var leftModel = m4.axisRotation([0, 1, 0], Math.PI * 0.5);
	var rightModel = m4.axisRotation([0, 1, 0], Math.PI * -0.5);
	var downModel = m4.axisRotation([0, 1, 0], Math.PI);
	upModel = m4.translate(upModel, [-240, 0, 0]);
	leftModel = m4.translate(leftModel, [160, 0, -120]);
	rightModel = m4.translate(rightModel, [-160, 0, 360]);
	downModel = m4.translate(downModel, [240, 0, 320]);
	
	var upModView = Tmodelview;
	var leftModView = m4.multiply(leftModel, Tcamera);
	var rightModView = m4.multiply(rightModel, Tcamera);
	var downModView = m4.multiply(downModel, Tcamera);
	
	var upAxis = [0, 0, 1];
	var downAxis = [0, 0, 1];
	var leftAxis = [0, 0, 1];
	var rightAxis = [0, 0, 1];
	
	//arrow objects
	var upArrow = {xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr:75, sColor: "white", fColor: "rgb(189,32,49)", direction: "up", currAngle: 0};
	var downArrow = {xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr:75, sColor: "white", fColor: "rgb(189,32,49)", direction: "down", currAngle: 0};
	var leftArrow = {xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr: 75, sColor: "white", fColor: "rgb(189,32,49)", direction: "left", currAngle: 0};
	var rightArrow = {xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr: 75, sColor: "white", fColor: "rgb(189,32,49)", direction: "right", currAngle: 0};
	
	//speed the arrows spin
	var spinSpeed = Math.PI / 45;
	
	//speed the arrows recover at after spin
	var recoverSpeed = Math.PI / 10;
	
	//backdrop
	var background = {xc: 0, yc: -1, zc: 0, xr: 1600, yr: 1, zr:1600, color: "black"};
	
	//queue divider
	var divider = {xc: 40, yc: 0, zc: 0, xr: 5, yr: 5, zr:800, color: "white", fColor: "rgb(189,32,49)", direction: "up"};
	
	//queue of arrow commands
	var arrowQueue = [];
	
	//temporary model used to make model views for queue
	var tempModel;
	
	//game variable, whether game is running or over
	var game = "running";
	
	//current scrolling height in arrow queue
	var scrollHeight = 0;
	
	//main loop
	function update() {
	
		//clear canvas
		canvas.width = canvas.width;
		
		updateCamera();
		
		//draw the background
		drawCube(background, Tmodelview);
		
		
		//resetGame();
		spinArrows();
		
		addToArrowQueue();
		undoArrowQueue();
		moveArrowQueue();
		buildArrowQueue();
		drawArrowQueue();
		
		if(arrowQueue.length > 1) {
			console.log("direction = " + arrowQueue[1].direction);
			console.log("radius = " + arrowQueue[1].xr);
			console.log("height = " + arrowQueue[1].height);
			console.log("length = " + arrowQueue.length);
		}
		
		
		
		//draw the arrows
		drawArrow(upArrow, upModView);
		drawArrow(leftArrow, leftModView);
		drawArrow(downArrow, downModView);
		drawArrow(rightArrow, rightModView);
		
		//draw the dividing line-height
		drawCube(divider, Tmodelview);		
		
		window.requestAnimationFrame(update);
	}
	
	//bring ui to original setup
	function resetGame() {
		
	}
	
	//turn newly sent arrow commands into arrows
	function addToArrowQueue() {
	
		while(newArrows.length > 0) {
			
			//turn the command into an arrow
			//arrowQueue.push(upArrow);
			arrowQueue.push({xc: 0, yc: 0, zc: 0, xr: 37.5, yr: 5, zr:75, sColor: "white", fColor: "rgb(189,32,49)", direction: "up"});
			
			//set the direction of the arrow
			arrowQueue[arrowQueue.length - 1].direction = newArrows[0];
			
			//set the position of the arrow
			arrowQueue[arrowQueue.length - 1].height = -150 * (arrowQueue.length - 1) + 300;
			
			//scale the arrow
			arrowQueue[arrowQueue.length - 1].xr *= 0.5;
			arrowQueue[arrowQueue.length - 1].yr *= 0.5;
			arrowQueue[arrowQueue.length - 1].zr *= 0.5;
			
			//dequeue the arrow added
			newArrows.shift();
		}
		
	}
	
	//undo arrows on queue
	function undoArrowQueue() {
		
		//undo an arrow for each undo move
		while(undoMoves > 0) {
		
			if(arrowQueue.length > 0 && queueSpeed == 0) {
				arrowQueue.pop();
			}
			
			undoMoves--;
			
		}
	}
	
	//move arrows in arrow queue after being submitted
	function moveArrowQueue() { 
	
		for(var i = 0; i < arrowQueue.length; i++) {
			arrowQueue[i].height += queueSpeed;
			
		}
	}
	
	//create model views for arrow queue
	function buildArrowQueue() {
	
		//get the scroll height
		if(arrowQueue.length > 7) {
			scrollHeight = 150 * (arrowQueue.length - 7);
		}
		else {
			scrollHeight = 0;
		}
	
		for(var i = 0; i < arrowQueue.length; i++) {
			//position the arrow
			arrowQueue[i].model = m4.translation([140, 0, arrowQueue[i].height + scrollHeight]);
			
			//set the direction
			if(arrowQueue[i].direction == "down") {
				arrowQueue[i].model = m4.axisRotate(arrowQueue[i].model, [0, 1, 0], Math.PI);
			}
			if(arrowQueue[i].direction == "left") {
				arrowQueue[i].model = m4.axisRotate(arrowQueue[i].model, [0, 1, 0], Math.PI * 0.5);
			}
			if(arrowQueue[i].direction == "right") {
				arrowQueue[i].model = m4.axisRotate(arrowQueue[i].model, [0, 1, 0], Math.PI * -0.5);
			}
			
			
			arrowQueue[i].modelView = m4.multiply(arrowQueue[i].model, Tcamera);
			
		}
		
	}
	
	//draw the arrow queue
	function drawArrowQueue() {
		for(var i = 0; i < arrowQueue.length; i++) {
			
			drawArrow(arrowQueue[i], arrowQueue[i].modelView);
			
		}
		
		console.log(arrowQueue.length + " arrows drawn");
	}
	
	//spin the arrows when clicked
	function spinArrows() {
		
		//spin up arrow
		if(upSpin > 0) {
			upArrow.fColor = "rgb(153,50,204)";
			upModel = m4.axisRotate(upModel, upAxis, spinSpeed * upSpeed);
			upModView = m4.multiply(upModel, Tcamera);
		}
		
		//spin down arrow
		if(downSpin > 0) {
			downArrow.fColor = "rgb(153,50,204)";
			downModel = m4.axisRotate(downModel, downAxis, spinSpeed * downSpeed);
			downModView = m4.multiply(downModel, Tcamera);
		}
		
		//spin left arrow
		if(leftSpin > 0) {
			leftArrow.fColor = "rgb(153,50,204)";
			leftModel = m4.axisRotate(leftModel, leftAxis, spinSpeed * leftSpeed);
			leftModView = m4.multiply(leftModel, Tcamera);
		}
		
		//spin right arrow
		if(rightSpin > 0) {
			rightArrow.fColor = "rgb(153,50,204)";
			rightModel = m4.axisRotate(rightModel, rightAxis, spinSpeed * rightSpeed);
			rightModView = m4.multiply(rightModel, Tcamera);
		}
		
		//calulate amonut of spin remaining
		upSpin -= spinSpeed * upSpeed;
		upArrow.currAngle -= spinSpeed * upSpeed;
		if(upArrow.currAngle < 0) {
			upArrow.currAngle = Math.PI * 2 + upArrow.currAngle;
		}
		
		downSpin -= spinSpeed * downSpeed;
		downArrow.currAngle -= spinSpeed * downSpeed;
		if(downArrow.currAngle < 0) {
			downArrow.currAngle = Math.PI * 2 + downArrow.currAngle;
		}
		
		leftSpin -= spinSpeed * leftSpeed;
		leftArrow.currAngle -= spinSpeed * leftSpeed;
		if(leftArrow.currAngle < 0) {
			leftArrow.currAngle = Math.PI * 2 + leftArrow.currAngle;
		}
		
		rightSpin -= spinSpeed * rightSpeed;
		rightArrow.currAngle -= spinSpeed * rightSpeed;
		if(rightArrow.currAngle < 0) {
			rightArrow.currAngle = Math.PI * 2 + rightArrow.currAngle;
		}
		
		//cannot have negative spin remaining, make sure arrows end at correct angle
		if(upSpin <= 0) {
			upSpin = 0;
			upSpeed = 0;
			upArrow.fColor = "rgb(189,32,49)";
			if(upArrow.currAngle > recoverSpeed) {
				upArrow.currAngle -= recoverSpeed;
				upModel = m4.axisRotate(upModel, upAxis, recoverSpeed);
				upModView = m4.multiply(upModel, Tcamera);
			}
			else if(upArrow.currAngle > 0) {
				upModel = m4.axisRotate(upModel, upAxis, upArrow.currAngle);
				upModView = m4.multiply(upModel, Tcamera);
				upArrow.currAngle = 0;
			}
		}
		if(downSpin <= 0) {
			downSpin = 0;
			downSpeed = 0;
			downArrow.fColor = "rgb(189,32,49)";
			if(downArrow.currAngle > recoverSpeed) {
				downArrow.currAngle -= recoverSpeed;
				downModel = m4.axisRotate(downModel, downAxis, recoverSpeed);
				downModView = m4.multiply(downModel, Tcamera);
			}
			else if(downArrow.currAngle > 0) {
				downModel = m4.axisRotate(downModel, downAxis, downArrow.currAngle);
				downModView = m4.multiply(downModel, Tcamera);
				downArrow.currAngle = 0;
			}
		}
		if(leftSpin <= 0) {
			leftSpin = 0;
			leftSpeed = 0;
			leftArrow.fColor = "rgb(189,32,49)";
			if(leftArrow.currAngle > recoverSpeed) {
				leftArrow.currAngle -= recoverSpeed;
				leftModel = m4.axisRotate(leftModel, leftAxis, recoverSpeed);
				leftModView = m4.multiply(leftModel, Tcamera);
			}
			else if(leftArrow.currAngle > 0) {
				leftModel = m4.axisRotate(leftModel, leftAxis, leftArrow.currAngle);
				leftModView = m4.multiply(leftModel, Tcamera);
				leftArrow.currAngle = 0;
			}
		}
		if(rightSpin <= 0) {
			rightSpin = 0;
			rightSpeed = 0;
			rightArrow.fColor = "rgb(189,32,49)";
			if(rightArrow.currAngle > recoverSpeed) {
				rightArrow.currAngle -= recoverSpeed;
				rightModel = m4.axisRotate(rightModel, rightAxis, recoverSpeed);
				rightModView = m4.multiply(rightModel, Tcamera);
			}
			else if(rightArrow.currAngle > 0) {
				rightModel = m4.axisRotate(rightModel, rightAxis, rightArrow.currAngle);
				rightModView = m4.multiply(rightModel, Tcamera);
				rightArrow.currAngle = 0;
			}
		}
	}
	
	//update the camera with new slider value
	function updateCamera() {
		
		//update main modelview
		angle1 = slider1.value*0.01*Math.PI;
		angle3 = (slider2.value * 3) + 300;
		
		eye=[Math.cos(-1.57) * 500,angle3,500*Math.sin(-1.57)];
		
        Tcamera=m4.inverse(m4.lookAt(eye,target,up));   
		Tmodelview=m4.multiply(Tmodel,Tcamera);
		upModView = m4.multiply(upModel, Tcamera);
	    leftModView = m4.multiply(leftModel, Tcamera);
	    rightModView = m4.multiply(rightModel, Tcamera);
	    downModView = m4.multiply(downModel, Tcamera);
		//console.log("angle1: " + angle1);
		//console.log(angle3);

	}
	
    drawAxes(Tcamera);
	update();	
	
  }
  draw();

}
window.onload = setup();

  </script>
</head>
<body>

</body>
</html>